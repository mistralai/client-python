"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .assistantmessage import AssistantMessage, AssistantMessageTypedDict
from .instructrequest_annotated_union_systemmessage_usermessage_assistantmessage_toolmessage_fieldinfo_annotation_nonetype_required_true_discriminator_role_tool_ import (
    InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleTool,
    InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolTypedDict,
)
from .modality import Modality
from .systemmessage import SystemMessage, SystemMessageTypedDict
from .tool import Tool, ToolTypedDict
from .toolmessage import ToolMessage, ToolMessageTypedDict
from .transcriptionparams import TranscriptionParams, TranscriptionParamsTypedDict
from .usermessage import UserMessage, UserMessageTypedDict
from mistralai.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from mistralai.utils import get_discriminator
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


InputsMessagesTypedDict = TypeAliasType(
    "InputsMessagesTypedDict",
    Union[
        SystemMessageTypedDict,
        UserMessageTypedDict,
        AssistantMessageTypedDict,
        ToolMessageTypedDict,
    ],
)


InputsMessages = Annotated[
    Union[
        Annotated[AssistantMessage, Tag("assistant")],
        Annotated[SystemMessage, Tag("system")],
        Annotated[ToolMessage, Tag("tool")],
        Annotated[UserMessage, Tag("user")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


class InputsInputsTypedDict(TypedDict):
    messages: List[InputsMessagesTypedDict]
    system_prompt: NotRequired[Nullable[str]]
    available_tools: NotRequired[Nullable[List[ToolTypedDict]]]
    truncate_at_max_tokens: NotRequired[Nullable[int]]
    truncate_at_max_image_tokens: NotRequired[Nullable[int]]
    output_modalities: NotRequired[Nullable[List[Modality]]]
    transcription_params: NotRequired[Nullable[TranscriptionParamsTypedDict]]


class InputsInputs(BaseModel):
    messages: List[InputsMessages]

    system_prompt: OptionalNullable[str] = UNSET

    available_tools: OptionalNullable[List[Tool]] = UNSET

    truncate_at_max_tokens: OptionalNullable[int] = UNSET

    truncate_at_max_image_tokens: OptionalNullable[int] = UNSET

    output_modalities: OptionalNullable[List[Modality]] = UNSET

    transcription_params: OptionalNullable[TranscriptionParams] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "system_prompt",
            "available_tools",
            "truncate_at_max_tokens",
            "truncate_at_max_image_tokens",
            "output_modalities",
            "transcription_params",
        ]
        nullable_fields = [
            "system_prompt",
            "available_tools",
            "truncate_at_max_tokens",
            "truncate_at_max_image_tokens",
            "output_modalities",
            "transcription_params",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChatClassificationRequestInputsTypedDict = TypeAliasType(
    "ChatClassificationRequestInputsTypedDict",
    Union[
        InputsInputsTypedDict,
        List[
            InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolTypedDict
        ],
    ],
)
r"""Chat to classify"""


ChatClassificationRequestInputs = TypeAliasType(
    "ChatClassificationRequestInputs",
    Union[
        InputsInputs,
        List[
            InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleTool
        ],
    ],
)
r"""Chat to classify"""


class ChatClassificationRequestTypedDict(TypedDict):
    model: str
    inputs: ChatClassificationRequestInputsTypedDict
    r"""Chat to classify"""
    truncate_for_context_length: NotRequired[bool]


class ChatClassificationRequest(BaseModel):
    model: str

    inputs: Annotated[ChatClassificationRequestInputs, pydantic.Field(alias="input")]
    r"""Chat to classify"""

    truncate_for_context_length: Optional[bool] = False
