"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .assistantmessage import AssistantMessage, AssistantMessageTypedDict
from .modality import Modality
from .systemmessage import SystemMessage, SystemMessageTypedDict
from .tool import Tool, ToolTypedDict
from .toolmessage import ToolMessage, ToolMessageTypedDict
from .transcriptionparams import TranscriptionParams, TranscriptionParamsTypedDict
from .usermessage import UserMessage, UserMessageTypedDict
from mistralai.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from mistralai.utils import get_discriminator
from pydantic import Discriminator, Tag, model_serializer
from typing import List, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolMessagesTypedDict = TypeAliasType(
    "InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolMessagesTypedDict",
    Union[
        SystemMessageTypedDict,
        UserMessageTypedDict,
        AssistantMessageTypedDict,
        ToolMessageTypedDict,
    ],
)


InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolMessages = Annotated[
    Union[
        Annotated[AssistantMessage, Tag("assistant")],
        Annotated[SystemMessage, Tag("system")],
        Annotated[ToolMessage, Tag("tool")],
        Annotated[UserMessage, Tag("user")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


class InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolTypedDict(
    TypedDict
):
    messages: List[
        InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolMessagesTypedDict
    ]
    system_prompt: NotRequired[Nullable[str]]
    available_tools: NotRequired[Nullable[List[ToolTypedDict]]]
    truncate_at_max_tokens: NotRequired[Nullable[int]]
    truncate_at_max_image_tokens: NotRequired[Nullable[int]]
    output_modalities: NotRequired[Nullable[List[Modality]]]
    transcription_params: NotRequired[Nullable[TranscriptionParamsTypedDict]]


class InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleTool(
    BaseModel
):
    messages: List[
        InstructRequestAnnotatedUnionSystemMessageUserMessageAssistantMessageToolMessageFieldInfoAnnotationNoneTypeRequiredTrueDiscriminatorRoleToolMessages
    ]

    system_prompt: OptionalNullable[str] = UNSET

    available_tools: OptionalNullable[List[Tool]] = UNSET

    truncate_at_max_tokens: OptionalNullable[int] = UNSET

    truncate_at_max_image_tokens: OptionalNullable[int] = UNSET

    output_modalities: OptionalNullable[List[Modality]] = UNSET

    transcription_params: OptionalNullable[TranscriptionParams] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "system_prompt",
            "available_tools",
            "truncate_at_max_tokens",
            "truncate_at_max_image_tokens",
            "output_modalities",
            "transcription_params",
        ]
        nullable_fields = [
            "system_prompt",
            "available_tools",
            "truncate_at_max_tokens",
            "truncate_at_max_image_tokens",
            "output_modalities",
            "transcription_params",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
